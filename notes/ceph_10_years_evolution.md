From: https://x.com/petereliaskraft/status/1906420979896893823

If you need to store files on disk, you use the filesystem, right?  Right?

Well, maybe not! I love this paper because it presents the lessons of 10 years spent building the popular distributed file system Ceph. Originally, Ceph did the obvious thing and stored files in the local file systems of their storage servers. But the semantics and performance of POSIX file systems weren’t quite what Ceph needed, and its developers spent 10 years fighting the operating system until eventually they gave up and built their own storage backend from scratch. As you read this paper, you can just feel the frustration of the authors as they keep trying and failing to get POSIX file systems to do what they need before taking matters into their own hands.

Ceph badly needed two critical properties that were hard to get from POSIX file systems. First, efficient transactions. A distributed file system like Ceph needs to transactionally update files to provide strong consistency. However, POSIX does not support transactions over files. Ceph tried a number of approaches to “build their own transactions” on top of POSIX, including leveraging file system internal transactions, implementing transactions in userspace using logs, and storing metadata in a transactional database and implementing transactions there. However, none of these approaches worked–internal transactions weren’t sufficiently flexible for external use, and user-space transactions required painfully slow journaling steps.

A second key problem Ceph encountered was the speed of metadata operations. Ceph frequently needs to enumerate files on disk for distributed operations like scrubbing or recovery, but scanning large directories is slow in most POSIX file systems. As a result, Ceph must keep directories small with large fanout, creating a new source of overhead in a gigantic number of nested directors.

To solve these problems, the developers of Ceph decided that if POSIX file systems couldn’t give them what they needed, they’d built it themselves. Thus, they designed BlueStore, a custom storage backend designed from scratch to support Ceph.

BlueStore is an incredibly complex and intricate system that I don’t have space to discuss here (read the paper!), but one big takeaway from its design is that the developers of Ceph were able to build it by keeping it as small as possible. They didn’t go out to build a complete optimized POSIX file system, but instead built a small, special-purpose interface designed specifically to provide storage for Ceph. As a result, they built it in two years (still a long time!) versus the ten years that full file systems usually take to mature and become production-ready. So if you need to build core infrastructure like a storage system from scratch, first, make sure you really need to (you usually don’t!), then carefully build the smallest possible system that provides the properties you need.
